import csv
import datetime
import default
from helpers import Battery
import numpy as np
from offer import add_du_detail, add_du_detail_summary
import pandas as pd
from preprocess import download_registration
from read import read_dispatch_prices
from reflect import extract_row
from multiprocessing.pool import ThreadPool as Pool
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()
import matplotlib.pyplot as plt
# plt.style.use(['science', 'ieee', 'no-latex'])
plt.style.use(['science', 'no-latex'])
import math


class SourceUnit:
    def __init__(self, duid):
        self.duid = duid
        self.total_cleared = None
        self.fcas = {}
        self.source = 'Other'
        self.disaptch_type = None
        self.classification = None
        self.region_id = None

    # def __repr__(self):
    #     return f'{self.duid} {self.source}'


def add_dispatchload(units, t, start, process, i, k=0, path_to_out=default.OUT_DIR, dispatchload_path=None):
    """ Add the dispatch load record generated by our model.

    Args:
        units (dict): the dictionary of units
        t (datetime.datetime): current datetime
        start (datetime.datetime): start datetime of the process
        process (str): 'dispatch', 'predispatch', or 'p5min'
        k (int): price-taker iteration number
        path_to_out (Path): path to the out directory

    Returns:
        None
    """
    if dispatchload_path is None:
        interval_datetime = default.get_case_datetime(t)
        if process == 'dispatch':
            path_to_file = path_to_out / (process if k == 0 else f'{process}_{k}') / f'dispatchload_{interval_datetime}.csv'
        else:
            path_to_file = path_to_out / (process if k == 0 else f'{process}_{k}') / f'{process}load_{default.get_case_datetime(start)}' / f'dispatchload_{interval_datetime}.csv'
    else:
        path_to_file = dispatchload_path
    with path_to_file.open() as f:
        reader = csv.reader(f)
        # logging.info('Read next day dispatch.')
        for row in reader:
            if row[0] == 'D' and len(row) > 3:
                duid = row[1]
                # if duid in units:
                unit = SourceUnit(duid)
                unit.total_cleared, unit.fcas = extract_row(row, unit.fcas)
                units[duid] = unit
                # if unit.energy is not None and unit.energy.daily_energy_limit != 0:
                #     unit.energy.daily_energy = float(row[4])
                #     unit.energy.daily_energy_record = float(row[5])
                #     # unit.energy.last_daily_energy = float(row[6])
                #     # unit.energy.last_daily_energy_record = float(row[7])
                if duid == 'G' or duid == 'L':
                    unit.dispatch_type = 'GENERATOR' if duid == 'G' else 'LOAD'
                    unit.region_id = 'NSW1'
                    unit.source = 'Our battery'
    return units


def add_registeration(units):
    path_to_registeration = download_registration(True)
    with pd.ExcelFile(path_to_registeration) as xls:
        df = pd.read_excel(xls, 'Generators and Scheduled Loads')
        for index, row in df.iterrows():
            unit = units.get(row['DUID'])
            if unit:
                if row['Fuel Source - Primary'] not in ['', ' ', '-', None, np.nan]:
                    unit.source = row['Fuel Source - Primary']
                else:
                    unit.source = 'Other'
                unit.dispatch_type = row['Dispatch Type']
                unit.classification = row['Classification']
                unit.region_id = row['Region']


def write_to_csv(energy):
    process = 'dispatch'
    # energy = 30
    power = int(energy / 3 * 2)
    usage = 'Cost-reflective + multiple FCAS'
    battery = Battery(energy, power, usage=usage)
    start = datetime.datetime(2021, 9, 12, 4, 5)
    fuels_gen_energy_revenues, fuels_load_energy_revenues = {}, {}
    fuels_gen_fcas_revenues, fuels_load_fcas_revenues = {}, {}

    energy_prices = []
    fcas_prices = {}

    for i in range(288 * 7):
        t = start + i * default.FIVE_MIN
        regions_price = read_dispatch_prices(t, process, True, None, k=0, path_to_out=battery.bat_dir, intervention='0', fcas_flag=True)
        # rrp, _, rrp_fcas_prices, _ = regions_price[battery.generator.region_id]
        # energy_prices.append(rrp)
        # for bid_type, price in rrp_fcas_prices.items():
        #     if bid_type not in fcas_prices:
        #         fcas_prices[bid_type] = []
        #     fcas_prices[bid_type].append(price)

        units = add_dispatchload({}, t + default.FIVE_MIN, start, process, i, k=0, path_to_out=battery.bat_dir, dispatchload_path=None)
        add_registeration(units)
        add_du_detail(units, t)
        add_du_detail_summary(units, t)

        for unit in units.values():
            rrp, _, fcas_prices, _ = regions_price[unit.region_id]
            unit.unit_energy_revenue = unit.total_cleared * rrp * 5 / 60
            unit.unit_fcas_revenue = sum([fcas_prices[bid_type] * unit.fcas[bid_type] * 5 / 60 for bid_type in fcas_prices.keys()])
            if unit.dispatch_type == 'GENERATOR':
                fuels_energy_revenues = fuels_gen_energy_revenues
                fuels_fcas_revenues = fuels_gen_fcas_revenues
            elif unit.dispatch_type == 'LOAD':
                fuels_energy_revenues = fuels_load_energy_revenues
                fuels_fcas_revenues = fuels_load_fcas_revenues
            else:
                print(f'{unit.duid} Dispatch Type Error!')
            if unit.source not in fuels_energy_revenues:
                fuels_energy_revenues[unit.source] = 0
            fuels_energy_revenues[unit.source] += unit.unit_energy_revenue
            if unit.source not in fuels_fcas_revenues:
                fuels_fcas_revenues[unit.source] = 0
            fuels_fcas_revenues[unit.source] += unit.unit_energy_revenue

    revenues = [fuels_gen_energy_revenues, fuels_load_energy_revenues, fuels_gen_fcas_revenues, fuels_load_fcas_revenues]
    already = set()
    path_to_csv = default.OUT_DIR / 'source' / f'{usage} {energy}MWh {power}MW {default.get_case_datetime(t)}.csv'
    with path_to_csv.open('w') as csv_file:
        writer = csv.writer(csv_file)
        writer.writerow(['Source Type', 'Generator Energy', 'Load Energy', 'Generator FCAS', 'Load FCAS'])
        for r1 in revenues:
            for source_type in r1.keys():
                if source_type not in already:
                    row = [source_type]
                    for r2 in revenues:
                        row.append(r2.get(source_type, 0))
                    writer.writerow(row)
                    already.add(source_type)


def read_from_csv(path_to_csv, source_revenues):
    with path_to_csv.open('r') as f:
        reader = csv.reader(f)
        for row in reader:
            if row[0] in source_revenues:
                source_revenues[row[0]].append(float(row[1]) + float(row[3]))


def plot_source(energies, source_revenues):
    fig, ax1 = plt.subplots()
    ax1.set_xlabel('Battery Size (MWh)')
    ax1.set_ylabel('Revenue ($)')
    # ax1.set_xscale('log')
    # ax1.set_yscale('log')
    for source_t, source_r in source_revenues.items():
        # ax1.plot([math.log10(e) for e in energies], [math.log10(s) for s in source_r], 'o-', label=source_t)
        ax1.plot(energies, source_r, 'o-', label=source_t)
    plt.legend()
    plt.show()
    path_to_fig = default.OUT_DIR / 'source' / 'source.jpg'
    plt.savefig(path_to_fig)


def read_information(battery, start, total_intervals):
    generation_by_source = {
        'Solar': [],
        'Fossil': [],
        'Wind': [],
        'Hydro': [],
        'Renewable/ Biomass / Waste': [],
        'Battery storage': [],
        'Other': [],
        'Our battery': []
    }
    for i in range(total_intervals):
        each_generation_by_source = {
            'Solar': 0,
            'Fossil': 0,
            'Wind': 0,
            'Hydro': 0,
            'Renewable/ Biomass / Waste': 0,
            'Battery storage': 0,
            'Other': 0,
            'Our battery': 0
        }
        t = start + (1440 / total_intervals) * default.ONE_MIN * i
        units = add_dispatchload({}, t, t, 'dispatch', i, path_to_out=battery.bat_dir)
        add_registeration(units)
        add_du_detail(units, t)
        add_du_detail_summary(units, t)
        for unit in units.values():
            # if unit.region_id == 'NSW1' and unit.dispatch_type == 'GENERATOR':
            if unit.dispatch_type == 'LOAD':
                each_generation_by_source[unit.source] += unit.total_cleared
        for source_type, generation in each_generation_by_source.items():
            generation_by_source[source_type].append(generation)
    print(generation_by_source)
    path_to_fig = default.OUT_DIR / 'source' / 'All Load + Battery.jpg'
    plot_stackplots(generation_by_source, path_to_fig)


def plot_stackplots(generation_by_source, path_to_fig):
    hour = range(24)
    fig, ax = plt.subplots()
    ax.stackplot(hour, generation_by_source.values(),
                 labels=generation_by_source.keys(), alpha=0.8)
    ax.legend(loc='upper left')
    # ax.set_title('World population')
    ax.set_xlabel('Time (hour)')
    ax.set_ylabel('Schedule (MW)')
    # plt.show()
    plt.savefig(path_to_fig)


if __name__ == '__main__':
    # source_revenues = {
    #     'Solar': [],
    #     'Fossil': [],
    #     'Wind': [],
    #     'Hydro': [],
    #     'Renewable/ Biomass / Waste': [],
    #     'Battery storage': [],
    #     'Other': []
    # }
    # energies = [3, 30, 3000]
    # energies = [3, 30, 120, 240, 360, 480, 720, 960, 1200, 2100, 3000]  # Cost-reflective + multiple FCAS
    # with Pool(len(energies)) as pool:
    #     pool.map(write_to_csv, energies)
    # t = datetime.datetime(2021, 9, 19, 4, 0)
    # usage = 'Cost-reflective + multiple FCAS'
    # for e in energies:
    #     p = int(e / 3 * 2)
    #     path_to_csv = default.OUT_DIR / 'source' / f'{usage} {e}MWh {p}MW {default.get_case_datetime(t)}.csv'
    #     read_from_csv(path_to_csv, source_revenues)
    # plot_source(energies, source_revenues)

    e = 3000
    battery = Battery(e, int(e * 2 / 3), usage='DER None Integration Hour')
    start = datetime.datetime(2021, 7, 18, 4, 35)
    read_information(battery, start, 24)